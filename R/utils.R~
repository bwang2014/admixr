#' Tabulate occurences in a vector
#'
#' @param x A vector of values
#' @return A named vector with occurences of the elements of x, sorted along x
#' @examples
#' fastTable(c(1:5, 2))
#' fastTable(c("D", "A", "C", "C"))
fastTable <- function(x){
    uniqueX <- sort(unique(x))
    idx <- match(x, uniqueX)
    res <- tabulate(idx)
    names(res) <- uniqueX
    return(res)
}

#' Get allele counts from a genotype matrix
#'
#' Takes a  genotype matrix coded as 0,1,2 as input and returns an
#' array with the counts of the two alleles
#' for each SNP in each population
#'
#' @param gt A matrix of genotypes, dimensions SNPs x individuals
#' @param popIdx A vector specifying the population label for each individual (column) of the genotype matrix
#' @param isHaploid Optional flag if genotype matrix represents haploid data coded as homozygous diploid, i.e. only 0 or 2 entries
#' @return An array with dimensions (SNPs x Populations x 2)
getAlleleCountsGT <- function(gt, popIdx, isHaploid = FALSE){

    ## helpers
    popIds <- unique(popIdx)
    nPops <- length(popIds)
    nMarkers <- nrow(gt)

    ## number of nonmissing genotypes
    gtM <- matrix(as.integer(!is.na(gt)), ncol = ncol(gt))
    nObs <- t(rowsum(t(gtM), popIdx, reorder = FALSE)) * as.integer(2)

    ## number of alternative alleles per pop & snp
    nAlt <- t(rowsum(t(gt), popIdx, reorder = FALSE, na.rm = TRUE))
    nAlt[nObs == 0] <- NA ## set alt allele count for SNPs without data to NA

    ## build array of counts for marker * population * allele
    counts <- array(NA, dim = c(nMarkers, nPops, 2), dimnames = list(marker = rownames(gt), population = popIds, allele = c("allele1", "allele2")))
    counts[,,2] <- nAlt
    counts[,,1] <- nObs - counts[,,2] ## nObs == 0 SNPs will be set to NA here, since nAlt for those is NA
    if(isHaploid){
        counts <- counts %/% as.integer(2) ## integer division to avoid conversion to numeric
    }
    return(counts)
}


#' Get FST from genotypes
#'
#' Takes a matrix genotypes as input and calculates FST (Weir and Cockerham 1984)
#' over all populations in the input data. Options to report per SNP
#' or whole region FST value, as well as extended output
#' of individual terms for estimats
#'
#' @param gt genotype matrix, dimensions SNPs x individuals
#' @param popIdx A vector specifying the population label for each individual (column) of the genotype matrix
#' @param region optional flag to return average FST for whole input region
#' @param extended optional flag to return all terms for per-SNP FST
#' @return 
#' \itemize{
#'   \item region = TRUE .. average FST over region
#'   \item region = FALSE, extended = FALSE .. a vector of FST per marker
#'   \item region = FALSE, extended = TRUE .. a matrix with numerator and denominator terms of FST (a, b, c in Weir & Cockerham 1984)
#' }
getFstGT <- function(gt, popIdx, region = FALSE, extended = FALSE){

    if(region & extended) stop("'region' & 'extended' flags can't be used together")

    ## set up helper terms
    r <- length(unique(popIdx)) ## number of populations
    gtM <- matrix(as.integer(!is.na(gt)), ncol = ncol(gt)) ## index matrix for non-missing genotypes
    isHet <- matrix(as.integer(gt == 1), ncol = ncol(gt)) ## index matrix for heterozygpote genotypes

    nI <- t(rowsum(t(gtM), popIdx, reorder = FALSE)) ## sample size per SNP and population
    pIBar <- t(rowsum(t(gt), popIdx, reorder = FALSE, na.rm = TRUE)) / nI / 2 ## sample allele frequency per SNP and population
    hIBar <- t(rowsum(t(isHet), popIdx, reorder = FALSE, na.rm = TRUE)) / nI ## proportion of heterozygote individuals per SNP and population

    nBar <- rowSums(nI) / r ## average sample size
    nC <- (r *  nBar - rowSums(nI^2 / (r * nBar))) / (r - 1)

    pBar <- rowSums(nI * pIBar / (r * nBar)) ## average sample allele frequency
    sSqu <- rowSums(nI * (pIBar - pBar)^2 / ((r - 1) * nBar)) ## variance of sample allele frequency
    hBar <- rowSums(nI * hIBar / (r * nBar))  ## average het frequency

    ## final terms for estimator
    a <- nBar/nC * (sSqu - (pBar*(1-pBar) - sSqu*(r-1)/r - hBar/4) / (nBar-1)) 
    b <- nBar / (nBar - 1) * (pBar * (1 - pBar) - (r - 1) / r * sSqu - (2 * nBar - 1) / (4 * nBar) * hBar)
    c <- hBar / 2

    ## return results
    res <- a / (a + b + c)
    if(region){
        res <- sum(a) / sum(a + b + c)
    }
    if(extended){
        res <- cbind(a, b, c)
    }
    return(res)
}


#' Get FST from allele counts
#'
#' Takes an array of allele counts input and calculates FST over all populations
#' in the input data. This is the moment estimator of Weir and Hill (2002)
#' using sample allele frequncies, assumes no local inbreeding.
#' Options to report per SNP or whole region FST value, as well as
#' extended output of numerator and denominator terms
#'
#' @param p allele counts array, dimensions SNPs x individuals x 2
#' @param region optional flag to return average FST for whole input region
#' @param extended optional flag to also return numerator and denominator terms for per-SNP FST
#' @return 
#' \itemize{
#'   \item region = TRUE .. average FST over region
#'   \item region = FALSE, extended = FALSE .. a vector of FST per marker
#'   \item region = FALSE, extended = TRUE .. a matrix with numerator and denominator terms of FST, as well per marker FST
#' }
getFstAlleleCounts <- function(p, region = FALSE, extended = FALSE){

    if(region & extended) stop("'region' & 'extended' flags can't be used together")

    ## set up helper terms
    r <- dim(p)[[2]] ## number of populations
    u <- dim(p)[[3]] ## number of alleles
    nI <- rowSums(p, dims = 2) ## sample size (number of alleles) per SNP and population, 
    nIC <- nI - nI^2 / rowSums(nI)
    nC <- rowSums(nIC) / (r - 1)

    pI <- p / as.vector(nI) ## frequency of each allele per SNP and population
    pBar <- apply(pI, 3, function(x){
        rowSums(x * nI) / rowSums(nI)
    }) ## average frequency of each allele over all populations per SNP

    msp1 <- sapply(1:u, function(x){
        rowSums(nI * (pI[,, x] - pBar[, x])^2)
    })
    msp <- msp1 / (r - 1) ## mean squares among populations

    msg1 <- sapply(1:u, function(x){
        rowSums(nI * pI[,, x] * (1 - pI[,, x]))
    })
    msg <- msg1 / rowSums(nI - 1) ## mean squares within populations 
   
    ## build final reults
    num <- rowSums(msp - msg) ## numerator term, summed over all alleles
    denom <- rowSums(msp + (nC - 1) * msg)

    if(region){
        theta <- sum(num) / sum(denom)
    } else {
        theta <- num / denom
    }
    if(extended){
        theta <- cbind(num, denom, theta)
    }
    return(theta)
}
